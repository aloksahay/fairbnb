import Foundation
import UIKit

// Self Configuration Structure (matches backend)
struct SelfConfig: Codable {
    let appName: String
    let scope: String
    let endpoint: String
    let endpointType: String?
    let logoBase64: String?
    let userId: String
    let userIdType: String
    let version: Int
    let devMode: Bool?
    let userDefinedData: String
    let disclosures: SelfDisclosures    
    let redirectURL: String?
}

struct SelfDisclosures: Codable {
    // Identity fields (optional)
    let issuing_state: Bool?
    let name: Bool?
    let passport_number: Bool?
    let nationality: Bool?
    let date_of_birth: Bool?
    let gender: Bool?
    let expiry_date: Bool?
    
    // Verification requirements
    let minimumAge: Int?
    let excludedCountries: [String]?
    let ofac: Bool?
}

// Verification Result
struct SelfVerificationResult: Codable {
    let success: Bool
    let userAddress: String
    let userType: String
    let timestamp: Int
    let transactionHash: String?
    let error: String?
}

// Verification Status
struct SelfVerificationStatus: Codable {
    let isVerifiedHost: Bool
    let isVerifiedGuest: Bool
    let isPremiumUser: Bool
    let verificationTimestamp: Int
    let isValid: Bool
}

// Simplified verification check result
struct VerificationCheckResult: Codable {
    let walletAddress: String
    let isVerified: Bool
    let verificationDetails: SelfVerificationStatus
    let timestamp: String
}

@MainActor
class SelfVerificationService: ObservableObject {
    @Published var isVerifying = false
    @Published var verificationResult: SelfVerificationResult?
    @Published var verificationStatus: SelfVerificationStatus?
    @Published var errorMessage: String?
    
    private let baseURL = "https://f4f2-83-144-23-154.ngrok-free.app/api/self-verification"
    
    // MARK: - Verification Flow
    
    /// Start verification process for a Privy wallet user
    func startVerification(userAddress: String) async {
        await MainActor.run {
            self.isVerifying = true
            self.errorMessage = nil
        }
        
        do {
            // Generate deeplink using official Self SDK from backend
            let deeplink = try await generateDeeplink()
            
            // Open Self app with the deeplink
            await openSelfAppWithDeeplink(deeplink: deeplink)
            
        } catch {
            await MainActor.run {
                self.errorMessage = "Failed to start verification: \(error.localizedDescription)"
                self.isVerifying = false
            }
        }
    }
    
    /// Generate deeplink using official Self SDK from backend
    private func generateDeeplink() async throws -> String {
        guard let url = URL(string: "https://f4f2-83-144-23-154.ngrok-free.app/api/self/generate-deeplink") else {
            throw SelfVerificationError.invalidURL
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        // No body needed since there's only one user type
        request.httpBody = try JSONSerialization.data(withJSONObject: [:])
        
        let (data, response) = try await URLSession.shared.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse,
              httpResponse.statusCode == 200 else {
            throw SelfVerificationError.networkError
        }
        
        let apiResponse = try JSONDecoder().decode(APIResponse<DeeplinkResponse>.self, from: data)
        
        guard apiResponse.success, let deeplinkData = apiResponse.data else {
            throw SelfVerificationError.configurationFailed
        }
        
        return deeplinkData.deeplink
    }
    
    /// Open Self app using deeplink generated by official Self SDK
    private func openSelfAppWithDeeplink(deeplink: String) async {
        await MainActor.run {
            guard let url = URL(string: deeplink) else {
                print("ERROR: Invalid Self deeplink: \(deeplink)")
                self.errorMessage = "Invalid verification link"
                self.isVerifying = false
                return
            }
            
            print("DEBUG: Opening Self app with official SDK deeplink: \(deeplink)")
            
            // Use iOS Universal Links - this is the recommended approach
            UIApplication.shared.open(url, options: [:]) { success in
                print("DEBUG: Self app deeplink open result: \(success)")
                
                if !success {
                    print("DEBUG: Self app not installed, opening App Store")
                    self.openSelfAppStore()
                } else {
                    print("DEBUG: Successfully opened Self app for verification")
                    // Schedule a check to see if verification completed
                    self.scheduleVerificationCheck()
                }
            }
        }
    }
    
    /// Schedule verification check after opening Self app
    private func scheduleVerificationCheck() {
        // Schedule a check after some time to see if verification completed
        Task {
            // Wait for user to complete verification in Self app
            try? await Task.sleep(nanoseconds: 30_000_000_000) // 30 seconds
            
            // Check if we have a user address to verify
            if let userAddress = getCurrentUserAddress() {
                await checkVerificationStatus(userAddress: userAddress)
            }
        }
    }
    
    /// Test deeplink functionality (for development)
    func testDeeplink(config: SelfConfig) async -> DeeplinkTestResult {
        let universalLink = generateSelfDeeplink(config: config)
        let customScheme = generateCustomSchemeDeeplink(config: config)
        
        return await withCheckedContinuation { continuation in
            var testResult = DeeplinkTestResult()
            testResult.universalLink = universalLink
            testResult.customScheme = customScheme
            
            // Test if Self app is installed by trying to open it
            if let url = URL(string: universalLink) {
                UIApplication.shared.open(url, options: [:]) { success in
                    testResult.universalLinkWorking = success
                    testResult.selfAppInstalled = success
                    continuation.resume(returning: testResult)
                }
            } else {
                testResult.universalLinkWorking = false
                testResult.selfAppInstalled = false
                continuation.resume(returning: testResult)
            }
        }
    }
    
    /// Open Self app in App Store
    private func openSelfAppStore() {
        // Official Self app on the App Store
        let appStoreURL = "https://apps.apple.com/app/self-identity/id1552847672"
        
        print("DEBUG: Self app not installed, opening App Store: \(appStoreURL)")
        
        if let url = URL(string: appStoreURL) {
            UIApplication.shared.open(url) { success in
                if success {
                    self.errorMessage = "Please install the Self app from the App Store to continue verification."
                } else {
                    self.errorMessage = "Unable to open App Store. Please search for 'Self Identity' in the App Store."
                }
                self.isVerifying = false
            }
        } else {
            self.errorMessage = "Please install the Self app from the App Store to continue verification."
            self.isVerifying = false
        }
    }
    
    // MARK: - Status Checking
    
    /// Check verification status for a user using simplified endpoint
    func checkVerificationSimple(walletAddress: String) async -> Bool {
        do {
            guard let url = URL(string: "\(baseURL)/check-verification/\(walletAddress)") else {
                print("Error: Invalid URL for verification check")
                return false
            }
            
            let (data, response) = try await URLSession.shared.data(from: url)
            
            guard let httpResponse = response as? HTTPURLResponse,
                  httpResponse.statusCode == 200 else {
                print("Error: HTTP \((response as? HTTPURLResponse)?.statusCode ?? 0) - Failed to check verification status")
                return false
            }
            
            let apiResponse = try JSONDecoder().decode(APIResponse<VerificationCheckResult>.self, from: data)
            
            if apiResponse.success, let result = apiResponse.data {
                return result.isVerified
            } else {
                print("Error: API response unsuccessful or missing data")
                return false
            }
            
        } catch {
            print("Error checking verification status: \(error.localizedDescription)")
            return false
        }
    }
    
    /// Check verification status for a user
    func checkVerificationStatus(userAddress: String) async {
        do {
            guard let url = URL(string: "\(baseURL)/status/\(userAddress)") else {
                throw SelfVerificationError.invalidURL
            }
            
            print("DEBUG: Calling verification status URL: \(url)")
            
            let (data, response) = try await URLSession.shared.data(from: url)
            
            guard let httpResponse = response as? HTTPURLResponse,
                  httpResponse.statusCode == 200 else {
                print("DEBUG: HTTP error - Status code: \((response as? HTTPURLResponse)?.statusCode ?? 0)")
                throw SelfVerificationError.networkError
            }
            
            print("DEBUG: Raw response data: \(String(data: data, encoding: .utf8) ?? "Unable to decode")")
            
            let apiResponse = try JSONDecoder().decode(APIResponse<SelfVerificationStatus>.self, from: data)
            
            print("DEBUG: Parsed API response - Success: \(apiResponse.success), Data: \(String(describing: apiResponse.data))")
            
            await MainActor.run {
                if apiResponse.success {
                    self.verificationStatus = apiResponse.data
                    print("DEBUG: Set verificationStatus to: \(String(describing: self.verificationStatus))")
                } else {
                    self.errorMessage = "Failed to get verification status"
                    print("DEBUG: API response was not successful")
                }
            }
            
        } catch {
            print("DEBUG: Error in checkVerificationStatus: \(error)")
            await MainActor.run {
                self.errorMessage = "Error checking status: \(error.localizedDescription)"
            }
        }
    }
    
    /// Get verification requirements for Fairbnb
    func getVerificationRequirements() async -> VerificationRequirements? {
        do {
            guard let url = URL(string: "\(baseURL)/requirements") else {
                return nil
            }
            
            let (data, response) = try await URLSession.shared.data(from: url)
            
            guard let httpResponse = response as? HTTPURLResponse,
                  httpResponse.statusCode == 200 else {
                return nil
            }
            
            let apiResponse = try JSONDecoder().decode(APIResponse<VerificationRequirements>.self, from: data)
            return apiResponse.data
            
        } catch {
            await MainActor.run {
                self.errorMessage = "Error getting requirements: \(error.localizedDescription)"
            }
            return nil
        }
    }
    
    // MARK: - App State Management
    
    /// Handle app returning from Self verification
    func handleVerificationReturn() {
        // This should be called when the app returns from Self
        // You can implement polling or webhook handling here
        Task {
            // Wait a moment for the verification to process
            try? await Task.sleep(nanoseconds: 2_000_000_000) // 2 seconds
            
            // Check if we have a user address to verify
            if let userAddress = getCurrentUserAddress() {
                await checkVerificationStatus(userAddress: userAddress)
            }
            
            await MainActor.run {
                self.isVerifying = false
            }
        }
    }
    
    /// Get current user's Privy wallet address
    private func getCurrentUserAddress() -> String? {
        // Use the shared auth service instance
        return PrivyAuthService.shared.currentUser?.walletAddress
    }
    
    /// Reset verification state
    func resetVerificationState() {
        isVerifying = false
        verificationResult = nil
        verificationStatus = nil
        errorMessage = nil
    }
    
    /// Generate Self deeplink based on official Self documentation
    /// Reference: https://docs.self.xyz/use-self/use-deeplinking
    private func generateSelfDeeplink(config: SelfConfig) -> String {
        // According to official Self documentation, the process is:
        // 1. Create SelfAppBuilder with configuration
        // 2. Call build() to get the Self app object  
        // 3. Pass the Self app object to getUniversalLink()
        
        // Since we're in Swift and don't have the JavaScript SDK, we need to
        // simulate what SelfAppBuilder.build() and getUniversalLink() would do
        
        // Create the configuration object that matches SelfAppBuilder format from docs
        let selfAppConfig: [String: Any] = [
            "appName": config.appName,
            "scope": config.scope,
            "endpoint": config.endpoint,
            "logoBase64": config.logoBase64 ?? "",
            "userId": config.userId,
            "userIdType": config.userIdType,
            "version": config.version,
            "userDefinedData": config.userDefinedData,
            "disclosures": config.disclosures as Any
        ]
        
        // Convert to JSON and base64 encode (this simulates what the JS SDK does internally)
        do {
            let jsonData = try JSONSerialization.data(withJSONObject: selfAppConfig, options: [])
            let base64Config = jsonData.base64EncodedString()
            
            // Generate the universal link following Self's official pattern
            // This is what getUniversalLink() would return based on the documentation
            let universalLink = "https://app.self.xyz/verify?config=\(base64Config)"
            
            print("DEBUG: Generated official Self universal link: \(universalLink)")
            return universalLink
            
        } catch {
            print("ERROR: Failed to encode Self configuration: \(error)")
            
            // Fallback to simplified query parameters based on V2 format
            let fallbackLink = "https://app.self.xyz/verify?" +
                "appName=\(config.appName.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? "")&" +
                "scope=\(config.scope.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? "")&" +
                "endpoint=\(config.endpoint.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? "")&" +
                "userId=\(config.userId.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? "")&" +
                "userIdType=\(config.userIdType.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? "")&" +
                "version=\(config.version)&" +
                "userDefinedData=\(config.userDefinedData.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? "")"
            
            print("DEBUG: Using fallback Self link: \(fallbackLink)")
            return fallbackLink
        }
    }
    
    /// Generate custom scheme deeplink (fallback)
    private func generateCustomSchemeDeeplink(config: SelfConfig) -> String {
        // Self might use a custom scheme like "self://verify" or "selfapp://verify"
        // This is a fallback for when universal links don't work
        let baseScheme = "self://verify"
        var components = URLComponents(string: baseScheme)!
        
        var queryItems: [URLQueryItem] = [
            URLQueryItem(name: "appName", value: config.appName),
            URLQueryItem(name: "scope", value: config.scope),
            URLQueryItem(name: "endpoint", value: config.endpoint),
            URLQueryItem(name: "userId", value: config.userId),
            URLQueryItem(name: "userIdType", value: config.userIdType),
            URLQueryItem(name: "version", value: String(config.version)),
            URLQueryItem(name: "userDefinedData", value: config.userDefinedData)
        ]
        
        // Add optional parameters
        if let endpointType = config.endpointType {
            queryItems.append(URLQueryItem(name: "endpointType", value: endpointType))
        }
        
        if let devMode = config.devMode {
            queryItems.append(URLQueryItem(name: "devMode", value: String(devMode)))
        }
        
        components.queryItems = queryItems
        return components.url?.absoluteString ?? baseScheme
    }
}

// MARK: - Supporting Types

/// Test result for deeplink functionality
struct DeeplinkTestResult {
    var universalLink: String = ""
    var customScheme: String = ""
    var universalLinkWorking: Bool = false
    var selfAppInstalled: Bool = false
    var testTimestamp: Date = Date()
    
    var description: String {
        return """
        Deeplink Test Results:
        - Universal Link: \(universalLink)
        - Custom Scheme: \(customScheme)
        - Universal Link Working: \(universalLinkWorking)
        - Self App Installed: \(selfAppInstalled)
        - Test Time: \(testTimestamp)
        """
    }
}

struct APIResponse<T: Codable>: Codable {
    let success: Bool
    let data: T?
    let message: String?
    let error: String?
}

struct DeeplinkResponse: Codable {
    let deeplink: String
    let userId: String
}

struct VerificationRequirements: Codable {
    let minimumAge: Int
    let requiredFields: [String]
    let ofacRequired: Bool
    let geographicRestrictions: Bool
    let excludedCountries: [String]?
    let description: String
}

enum SelfVerificationError: LocalizedError {
    case invalidURL
    case networkError
    case configurationFailed
    case verificationFailed
    
    var errorDescription: String? {
        switch self {
        case .invalidURL:
            return "Invalid URL"
        case .networkError:
            return "Network error"
        case .configurationFailed:
            return "Failed to get verification configuration"
        case .verificationFailed:
            return "Verification failed"
        }
    }
}

// MARK: - Privy Integration Extension
// Note: PrivyUserModel already has walletAddress property, no extension needed 
